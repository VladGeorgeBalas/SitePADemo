{"version":"1","records":[{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare"},"type":"lvl1","url":"/laborator1","position":0},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare"},"content":"","type":"content","url":"/laborator1","position":1},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl2":"Asigurarea lizibilitătii"},"type":"lvl2","url":"/laborator1#asigurarea-lizibilit-tii","position":2},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl2":"Asigurarea lizibilitătii"},"content":"","type":"content","url":"/laborator1#asigurarea-lizibilit-tii","position":3},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Denumiri și comentarii","lvl2":"Asigurarea lizibilitătii"},"type":"lvl3","url":"/laborator1#denumiri-i-comentarii","position":4},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Denumiri și comentarii","lvl2":"Asigurarea lizibilitătii"},"content":"Pentru ca un program să fie ușor de citit, este nevoie în primul rând ca numele\nvariabilelor și funcțiilor să fie bine alese și să descrie explicit scopul acestora în program.\nPrezența comentariilor în cod nu este opțională.\nFără ele, codul poate fi greu de înțeles chiar și de persoana care l-a scris.\nDe asemenea, expresiile matematice și/sau logice folosite e\nbine să fie cât mai simple: o linie de cod să facă un singur lucru.\n\nCele două exemple de cod de mai jos produc același rezultat.\nFuncționalitatea codului din primul exemplu este ușor de identificat.\nÎnsă doar în al doilea exemplu scopul codului este evident, datorită\nutilizării unor denumiri relevante pentru variabile.\nDeși codul din cea de-a doua variantă este mai lung,\nexpresia testată în if se citește mai ușor.\n\nif ((a == 1 || a == 2 || a == 12) && (b == 6 || b == 7) && (c < 16)) {\n    x = 1;\n} else {\n    x = 0;\n}\n\nDenumiri leneșe și expresii complicate\n\nisWinter = month == 1 || month == 2 || month == 12;\nisWeekend = day == 6 || day == 7;\nisLight = hour < 16;\n\nif (isWinter && isWeekend && isLight) {\n    ski = 1;\n} else {\n    ski = 0;\n}\n\nDenumiri descriptive și expresii simple","type":"content","url":"/laborator1#denumiri-i-comentarii","position":5},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Numere magice","lvl2":"Asigurarea lizibilitătii"},"type":"lvl3","url":"/laborator1#numere-magice","position":6},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Numere magice","lvl2":"Asigurarea lizibilitătii"},"content":"Numerele 0, 1 și 2, datorită sensurilor evidente pe care le au în diverse contexte, sunt\nsingurele care ar trebui să fie folosite ca atare.\nRestul valorilor constante care sunt necesare în program e bine să fie salvate în variabile,\npentru a evita eventuale confuzii, pentru a face codul ușor de citit și înțeles și pentru a\nușura eventualele modificări.\nIntră în această categorie dimensiunile de orice fel, numărul de zile dintr-o lună etc.","type":"content","url":"/laborator1#numere-magice","position":7},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Respectarea convențiilor","lvl2":"Asigurarea lizibilitătii"},"type":"lvl3","url":"/laborator1#respectarea-conven-iilor","position":8},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Respectarea convențiilor","lvl2":"Asigurarea lizibilitătii"},"content":"Este bine ca numele variabilelor și funcțiilor care se referă la lucruri similare să urmeze aceeași regulă.\nÎn exemplul următor, variabila folosită pentru aria cercului nu respectă convenția de nume.\nDeși în momentul în care îi este atribuită valoarea, scopul ei pare evident, faptul că\nnumele variabilei nu conține și denumirea formei geometrice pe care o reprezintă poate\ngenera confuzii ulterioare.\n\narea = M_PI * r * r;\narea_tri = 0.5 * b * h;\narea_square = l * l;\n\nNerespectarea convenției de nume\n\nO altă convenție care trebuie respectată se referă la ordinea parametrilor\nîn funcțiile cu scop asemănător.\n\nÎn exemplul următor, cele două funcții, pentru calculul mediei elementelor\nunui vector, respectiv ale unei matrici pătratice, nu respectă această regulă.\nDacă un programator va folosi funcția\nmeanVec, iar apoi imediat meanMat, cel mai probabil se va aștepta ca primul\nparametru al acesteia din urmă să fie tot structura pentru care se calculează media.\nÎn cazul particular al acestui exemplu, compilatorul va semnala imediat eroarea,\ndeoarece tipul datelor pentru cei doi parametri este diferit. Dacă se întâmplă, însă, ca\naceștia să aibă același tip de date, eroarea va fi mai greu de identificat.\n\nint meanVec(int vec[], int dim) {\n    int mean = 0, sum = 0;\n    int i;\n    for (i = 0; i < dim; i++) {\n        sum = sum + vec[i];\n    }\n    mean = sum / dim;\n    return mean;\n}\n\nint meanMat(int dim, int mat[]) {\n    int mean = 0, sum = 0;\n    int i, j;\n    for (i = 0; i < dim; i++) {\n        for (j = 0; j < dim; j++) {\n            sum = sum + mat[i][j];\n        }\n    }\n    mean = sum / (dim * dim);\n    return mean;\n}\n\nNerespectarea convenției de ordine a parametrilor\n\nÎn unele situații în care se lucrează cu variabile care testează valoarea de adevăr a\nunor expresii, programatorul poate decide să apeleze, de asemenea, la convenții.\n\nScopul codului din exemplul de mai jos este de a testa dacă\nînregistrările dintr-o bază de date asociate unui student sunt complete/valide.\nRegula folosită la introducerea datelor este următoarea: dacă respectivul câmp nu\nconține date, valoarea asociată acestuia este -1.\nProgramatorul decide să asocieze fiecărui câmp din baza de date câte o variabilă\n(booleană) care semnalează validitatea acestuia.\nAre două variante: fie valoarea variabilei va fi True (1) dacă respectivul\ncâmp conține date isValidID, fie valoarea ei va fi True dacă respectivul câmp\neste gol (isEmptyCNP).\nVa trebui să aleagă o variantă, adică să stabilească o convenție,\nși să o folosească pentru toate câmpurile.\nÎn caz contrar, ca în exemplu, codul este susceptibil la erori.\n\nif (student.id == -1) isValidID = 0\nif (student.cnp == -1) isEmptyCNP = 1\n\nNerespectarea convențiilor","type":"content","url":"/laborator1#respectarea-conven-iilor","position":9},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Cod duplicat","lvl2":"Asigurarea lizibilitătii"},"type":"lvl3","url":"/laborator1#cod-duplicat","position":10},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Cod duplicat","lvl2":"Asigurarea lizibilitătii"},"content":"Dacă o secvență de cod este folosită în cel puțin două locuri\ndiferite din program, atunci secvența respectivă trebuie să fie introdusă într-o funcție\nși apelată acolo unde este nevoie.\nAltfel, orice modificare adusă liniilor respective de cod\ntrebuie făcută în toate locurile în care apar.\nObservația este cu atât mai importantă în cazul în care\nsecvențele în cauză apar în fișiere diferite.\n\nAceastă observație este valabilă inclusiv în unele\nsituații când secvența de cod nu este folosită în mod identic\nîn mai multe părți din program, ci ușor modificată: se pot găsi soluții\npentru a trata unitar cazurile particulare de utilizare.\nUn exemplu în acest sens va fi discutat in laboratorul de astăzi.","type":"content","url":"/laborator1#cod-duplicat","position":11},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl2":"Asigurarea corectitudinii"},"type":"lvl2","url":"/laborator1#asigurarea-corectitudinii","position":12},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl2":"Asigurarea corectitudinii"},"content":"","type":"content","url":"/laborator1#asigurarea-corectitudinii","position":13},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Reutilizarea variabilelor","lvl2":"Asigurarea corectitudinii"},"type":"lvl3","url":"/laborator1#reutilizarea-variabilelor","position":14},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Reutilizarea variabilelor","lvl2":"Asigurarea corectitudinii"},"content":"Reutilizarea variabilelor pentru alte scopuri este, de obicei, descurajată,\ndeoarece poate duce la erori de logică, dacă nu se ține o evidență corectă a sensului\npe care îl are variabila în secvențe diferite de cod.\nFac excepție, firește, variabilele de tip contor, iar observația nu se aplică nici\nsuprascrierii unei variabile cu rezultatul prelucrării ei.","type":"content","url":"/laborator1#reutilizarea-variabilelor","position":15},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Scopul variabilelor","lvl2":"Asigurarea corectitudinii"},"type":"lvl3","url":"/laborator1#scopul-variabilelor","position":16},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Scopul variabilelor","lvl2":"Asigurarea corectitudinii"},"content":"Durata de viață a variabilelor trebuie să respecte scopul acestora: dacă o variabilă nu\neste necesară decât în interiorul unei funcții, ea nu trebuie să fie declarată\nca variabilă globală. Argumente în acest sens, dar și situații în care utilizarea\nvariabilelor globale în C nu este o problemă, găsiți \n\naici.","type":"content","url":"/laborator1#scopul-variabilelor","position":17},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Semnalarea rapidă a erorilor","lvl2":"Asigurarea corectitudinii"},"type":"lvl3","url":"/laborator1#semnalarea-rapid-a-erorilor","position":18},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl3":"Semnalarea rapidă a erorilor","lvl2":"Asigurarea corectitudinii"},"content":"Un cod bine scris va genera eventualele erori cât mai repede cu putință.\nCompilatorul face o serie de verificări în urma cărora se pot genera erori,\nprintre care verificarea sintaxei și a scrierii, a definirii și utilizării corecte a\ntipurilor de date, a apelării corecte de funcții (conform numărului de parametri și în\nce privește tipul datelor returnate).\nSe verifică, de asemenea, validitatea operațiilor matematice (cum ar fi împărțirea la 0)\nși a indexării în date de tip tablou (unde indexul trebuie să aibă mereu o valoare pozitivă).\n\nAceste verificări, care asigură (în parte) sănătatea codului sunt fie statice\n(static checks), fie dinamice (dynamic checks).\nDiferența între ele se referă la momentul în care se produc: înainte de compilare\n(static) sau la runtime (dinamic).\nLimbaje de programare diferite abordează diferit aceste verificări.\nSpre exemplu, C și C++ (ca și Java, Haskell, Pascal ș.a.) sunt limbaje\nde tip static typing, ceea ce înseamnă că tipurile variabilelor sunt cunoscute la compilare.\nPrintre limbajele de tip dynamic typing se numără Python, Lisp, PHP etc.\nÎn cazul acestora, verificarea tipului variabilelor se face în momentul în care\nprogramul se execută (la runtime).\n\nÎnsă erorile dintr-un program pot fi și de natură logică, pe care niciuna din\nverificările anterioare nu le poate observa.\nRămâne responsabilitatea programatorului să verifice dacă anumite condiții ce țin\nde logica algoritmului sunt îndeplinite și să semnaleze cât de repede se poate\ndacă nu sunt respectate.\nAltfel, erorile pot trece neobservate și genera confuzii mai târziu, făcând mai grea\nidentificarea lor.\n\nUn mod prin care programatorul se poate asigura că evită erorile este\nprin documentarea și verificarea presupunerilor.\nSpre exemplu, dacă se așteaptă ca o funcție să primească o variabilă\nce reprezintă o zi calendaristică, trebuie verificat faptul că valoarea\nprimită face parte din valorile admise.","type":"content","url":"/laborator1#semnalarea-rapid-a-erorilor","position":19},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl2":"Ghiduri de stil"},"type":"lvl2","url":"/laborator1#ghiduri-de-stil","position":20},{"hierarchy":{"lvl1":"Laborator 1 - Bune practici de programare","lvl2":"Ghiduri de stil"},"content":"Companiile au, de cele mai multe ori, ghiduri de stil pe care programatorii angajați\ntrebuie să le repecte, astfel încât programele pe care le dezvoltă să fie unitare,\niar membrilor echipei să le fie ușor să lucreze cu codul scris de colegi.\nDacă în cazul companiilor aceste documente sunt destinate uzului intern, unele\nuniversități sau profesori au făcut publice ghiduri similare, spre exemplu\n\n\nKrzyzanowski,\n\n\nPérez,\n\n\nCS50,\n\n\nThereska.\nDezvoltatorii kernel-ului Linux au, de asemenea, un \n\nghid de stil.\nPentru alte limbaje de programare există ghiduri universale, ce trebuie\nrespectate de toți programatorii, indiferent de afiliere, cum este cazul\n\n\npython.\n\nVeți observa că uneori regulile sunt diferite.\nSpre exemplu, unele ghiduri pentru limbajul C recomandă ca în cazul\ninstrucțiunilor decizionale acolada care deschide structura să fie plasată pe\naceeași linie cu aceasta, iar cea care o închide să fie plasată pe o linie separată.\nÎn cazul în care există și o ramură else, aceasta trebuie plasată\npe aceeași linie care închide ramura if, ca în exemplul de mai jos.\n\nif (x == 0) {\n    a = 5;\n} else {\n    a = 2 * x;\n}\n\nPoziționarea acoladelor - varianta 1\n\nAlte ghiduri acceptă o altă variantă de formatare a acestor instrucțiuni, în care toate acoladele sunt plasate pe linii distincte, ca în exemplul următor.\n\nif (x == 0)\n{\n    a = 5;\n}\nelse\n{\n    a = 2 * x;\n}\n\nPoziționarea acoladelor - varianta 2\n\nChiar dacă alegerea unei anumite variante poate părea o problemă de preferință personală,\ntoate au ca scop lizibilitatea codului.\nVarianta potrivită poate depinde, de asemenea, și de natura și complexitatea aplicațiilor.\n\nCu toate că limbajul C permite omiterea acoladelor atunci când blocul de cod conține o singură\nlinie, este recomandat ca ele să fie folosite și în această situație, pentru a semnala mai clar\nintenția din spatele respectivelor instrucțiuni.\nÎn plus, dacă este necesară adăugarea unor noi linii în blocul respectiv, inclusiv pentru a facilita\ndepanarea, acoladele trebuie introduse.","type":"content","url":"/laborator1#ghiduri-de-stil","position":21},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git"},"type":"lvl1","url":"/laborator2","position":0},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git"},"content":"","type":"content","url":"/laborator2","position":1},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Ce este git?"},"type":"lvl2","url":"/laborator2#ce-este-git","position":2},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Ce este git?"},"content":"Git este un sistem de management al proiectelor\nsoftware și de gestionare a versiunilor codului sursă.\nUn proiect software în Git se numește repository și poate conține fișiere cod sursă, baze de date,\nfișiere text cu documentație etc.\n\nÎn Git fiecare versiune a unui program se numește commit și conține modificările aduse\nunuia sau mai multor fișiere.\nAstfel, istoricul modificărilor este conținut în lista commiturilor și se poate reveni\ncu ușurință la o versiune anterioară a programelor.\nDe aceea este important ca fiecare commit să se refere la o singură modificare logică\n(inclusiv în cazul în care afectează mai multe fișiere).\n\nDatorită faptului că este un sistem distribuit,\nGit se pretează pentru lucrul în echipă, fiecare membru având o copie locală a software-ului,\niar modificările aduse de fiecare fiind integrate pe un server.\n\nFiecare programator își poate alege modalitatea în care salvează aceste modificări,\nînsă atunci când se lucrează în echipă trebuie ținut cont de faptul că ele pot afecta munca altor colegi.\nDe aceea, este o idee bună ca versiunile (commiturile) să fie funcționale (să se poată compila),\nchiar dacă nu sunt finalizate sau nu acoperă eventualele cazuri particulare.\n\nGit permite de asemenea crearea unor ramuri de dezvoltare separate (denumite branch-uri), astfel\nîncât funcționalitățile (eventual incomplete) create pe o anumită ramură să nu afecteze dezvoltarea\nîntregului software.\nRamura principală se numește, de regulă, main (sau master) și conține o versiune\nfuncțională și stabilă a software-ului.\nOperația prin care o ramură (ajunsă în stadiul final de dezvoltare) se integrează cu o\nalta se numește merge.\n\nPentru început vom vedea cum se creează și cum se folosește un repository local, iar apoi cum se\nsincronizează acesta cu unul aflat pe server (remote).","type":"content","url":"/laborator2#ce-este-git","position":3},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Instalare"},"type":"lvl2","url":"/laborator2#instalare","position":4},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Instalare"},"content":"Este necesar ca întâi să instalați Git, varianta pentru sistemul vostru de operare. \n\nStart here.\n\nÎn timpul instalării, în fereastra Adjusting the name of the initial branch in new repositories,\nalegeți Override the default branch name for new repositories, cu textul main.\nPentru restul ferestrelor puteți lăsa opțiunile implicite.","type":"content","url":"/laborator2#instalare","position":5},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Repository local"},"type":"lvl2","url":"/laborator2#repository-local","position":6},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Repository local"},"content":"Pentru a utiliza Git într-un proiect software e nevoie de inițializarea unui\nrepository în directorul care conține programele din proiect.\nApoi, ori de câte ori se aduc modificări unuia sau mai multor fișiere,\naceste modificări vor fi incluse într-un commit nou.\n\nToate aceste operații se realizează în linia de comandă (Command Prompt în Windows sau Terminal în Linux).","type":"content","url":"/laborator2#repository-local","position":7},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Configurare"},"type":"lvl2","url":"/laborator2#configurare","position":8},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Configurare"},"content":"Pentru a inițializa un repository nou, în linia de comandă navigați în directorul\ndorit și folosiți comanda:git init\n\nConfigurați apoi user-ul, cu nume și adresa de email (pot fi fictive dacă lucrați pe un\ncalculator din laborator):git config user.name \"Codin Codescu\"\ngit config user.email \"codin@codescu.com\"","type":"content","url":"/laborator2#configurare","position":9},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Utilizare"},"type":"lvl2","url":"/laborator2#utilizare","position":10},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Utilizare"},"content":"Crearea unui commit se realizează în două faze. Prima se numește staging și presupune semnalarea\nfișierelor modificate care urmează să fie integrate în noul commit.\nAceasta se face utilizând comanda git add.git add fisier1.c fisier2.cpp\n\nAceastă etapă reprezintă pregătirea pentru commit, iar modificările aduse aici sunt reversibile.\nSpre exemplu, comanda de mai jos elimină fisier2.cpp din lista celor ce vor fi incluse în commit:git restore --staged fisier2.cpp\n\nPuteți vedea oricând ce fișiere sunt staged utilizând comanda:git status\n\nAtunci când sunteți siguri că doriți să integrați modificările într-un nou commit, folosiți comanda:git commit -m \"subiect\"\n\nunde \"subiect\" conține o scurtă descriere (de preferat de cel mult 50 de caractere) a commitului.\nSe obișnuiește ca subiectul să fie redactat în modul imperativ, spre exemplu\n“Fix bug at line 202”, “Optimize memory usage in function myFunction”,\n“Add function to compute shortest path”, sau “Modify function myFunction to include NULL case”.\n\nDupă ce un commit a fost creat, acesta nu se mai poate modifica și va rămâne în istoricul proiectului.\nSe poate reveni, însă, la un commit anterior, în cazul în care în acesta s-au strecurat greșeli.","type":"content","url":"/laborator2#utilizare","position":11},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Conectarea la un repository remote"},"type":"lvl2","url":"/laborator2#conectarea-la-un-repository-remote","position":12},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Conectarea la un repository remote"},"content":"GitLab și \n\nGitHub  sunt două exemple de platforme ce oferă servicii de găzduire pentru software și care folosesc sistemul Git.","type":"content","url":"/laborator2#conectarea-la-un-repository-remote","position":13},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Conectare prin ssh"},"type":"lvl2","url":"/laborator2#conectare-prin-ssh","position":14},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Conectare prin ssh"},"content":"SSH (Secure Shell) este un protocol de rețea care permite conectarea în siguranță la alte calculatoare.\nAutentificarea se realizează printr-un sistem de criptare asimetric bazat pe o pereche de chei:\nuna publică (folosită pentru a cripta mesajele) și alta privată (folosită pentru a decripta mesajele).\n\nPentru a vă crea propria pereche de chei ssh, utilizați comanda:ssh-keygen\n\nVi se va cere să alegeți un director în care să salvați cele două chei.\nPentru a evita setări suplimentare ulterioare, alegeți directorul default, apăsând Enter. Implicit,\ndirectorul este C:\\Users\\<nume_utilizator>\\.ssh (sau /home/<nume_utilizator>/.ssh daca folositi Linux).\nÎn funcție de setările sistemului de operare, acest director ar putea fi hidden.\n\nAceasta generează două fișiere în directorul ales: unul conținând cheia publică, ce are\nextensia .pub și altul, cu aceeași denumire aleasă, dar fără extensie, conținând cheia privată.\n\nPentru a crea conexiunea cu serverul GitLab sau GitHub trebuie să adăugați cheia publică în\ncontul vostru (să copiați conținutul fișierului cu cheia publică):\n\nîn GitHub, la Profile -> Settings -> SSH and GPG keys -> New SSH key.\n\nîn GitLab, la Profile -> Preferences -> SSH keys -> Add a SSH key.\n\nDacă nu lucrați pe calculatorul personal și lăsați cheia privată SSH, oricine are acces la calculator va\nputea face modificări în contul vostru remote. În acest caz, asigurați-vă că atunci când ați terminat de\nlucru ștergeți perechea de chei din calculator. De fiecare dată când veți dori să vă conectați pe contul\nremote de pe un calculator nou va trebui să generați o nouă pereche de chei.","type":"content","url":"/laborator2#conectare-prin-ssh","position":15},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Repository remote"},"type":"lvl2","url":"/laborator2#repository-remote","position":16},{"hierarchy":{"lvl1":"Laborator 2 - Controlul versiunilor & Git","lvl2":"Repository remote"},"content":"Până acum ați creat un repository local. Este nevoie să creați și unul pe server, apoi să le sincronizați pe cele două.\n\nPentru a crea un repository nou,\n\nîn GitHub, la Profile -> Your repositories -> New.\n\nîn GitLab, la New Project -> Create Blank Project.\n\nÎn ambele variante, asigurați-vă că ați debifat opțiunea Initialize repository with a README.\nAceasta trebuie debifată deoarece urmează să încărcați pe server un repository local deja existent\nși aveți nevoie de un repository fără niciun commit pe server. Dacă ați fi bifat opțiunea, serverul\nar fi creat un prim commit pentru a adăuga fișierul README în proiect. Fiecare proiect trebuie să conțină,\nînsă, un fișier README, așadar îl veți crea voi ulterior.\n\nPentru a vă putea conecta repository-ul local la cel de pe server, specificați prin comanda git remote\nadresa repository-ului remote:git remote add origin git@github.com:user/repo.git\n\nAtât în GitHub, cât și în GitLab, adresa o obțineți navigând în repository,\napoi Code -> (Clone with) SSH.\n\nDupă ce ați executat comanda precedentă, origin va fi un alias pentru adresa\ngit@github.com:user/repo.git și îl veți putea folosi de fiecare dată când vreți să vă referiți\nla această adresă pentru a trimite modificările pe server sau a le prelua de acolo.\n\nÎn acest moment repository-ul vostru local este conectat la cel de pe server.\nPuteți avea mai multe copii locale (pe mai multe calculatoare) ale repository-ului remote,\niar ele pot fi sincronizate cu ajutorul următoarelor comenzi.\n\nPentru a obține cea mai nouă versiune a repository-ului de pe server, folosiți comanda git pull:git pull origin main\n\nObservați specificarea adresei (prin aliasul origin) de la care se\nface preluarea repository-ului. Iar main (sau alternativ master,\nîn funcție de cum a fost configurat repository-ul) se referă la branch-ul de pe care se face copierea.\n\nPentru a publica pe server commiturile create local se folosește comanda git push:git push origin main\n\nOrdinea acestor comenzi este importantă atunci când lucrați cu un repository remote,\nîn special atunci când colaborați cu alți programatori.\nÎnainte de a trimite pe server modificări (cu push) trebuie să vă\nasigurați că aveți ultima versiune a programului, altfel commiturile pe care încercați să\nle trimiteți vor fi în urma celor deja existente pe server, situație care se numește conflict.\nÎntr-o anumită măsură, conflictele sunt inevitabile dacă lucrați în echipă și mai mulți programatori\nmodifică în același timp același program sau aceeași secvență de cod.\nExistă un mecanism automat de rezolvare a conflictelor, însă în cazul în care acesta eșuează, ele trebuie\nrezolvate manual.\n\nPentru a evita situația în care există commituri noi în repository-ul remote, pe care nu le aveți\nlocal în momentul în care vreți să trimiteți modificări pe server, faceți pull înainte\nde push.\n\nPentru a vă obșnui cu git, găsiți \n\naici și \n\naici două tutoriale bune și \n\naici un joc.","type":"content","url":"/laborator2#repository-remote","position":17},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese"},"type":"lvl1","url":"/laborator3","position":0},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese"},"content":"","type":"content","url":"/laborator3","position":1},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"1) Numere aleatorii"},"type":"lvl2","url":"/laborator3#id-1-numere-aleatorii","position":2},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"1) Numere aleatorii"},"content":"În multe aplicații din statistică sau criptografie este necesară generarea unor numere aleatorii.\nEle sunt de asemenea utile în testarea performanțelor unui algoritm, când se folosesc, cel mai adesea, inputuri aleatorii pentru a evita testarea situațiilor favorabile sau defavorabile și a obține o medie realistă ce caracterizează performanțele.\n\nÎnsă, datorită naturii deterministe a calculatoarelor, acestea nu pot genera numere cu adevărat aleatorii.\nO pot face dacă se bazează pe procese externe, de regulă fizice, care produc astfel de numere, cum ar fi zgomotul atmosferic sau unele procese electromagnetice.\nÎn lipsa unui astfel de proces, numerele ce pot fi generate cu un calculator se numesc pseudo-aleatorii, adică\nau proprietăți suficient de asemănătoare celor aleatorii.\n\nGeneratoarele de numere pseudoaleatorii sunt algoritmi care folosesc o valoare de inițializare, denumită seed, pentru a genera numere ce urmăresc o anumită distribuție (uniformă, normală etc).\nPrezența seedului face ca outputul funcției să fie predictibil, spre deosebire de cazul numerelor cu adevărat aleatorii.\n\nÎn C, pentru a genera numere întregi aleatorii cu distribuție uniformă puteți folosi biblioteca time.h, după cum urmează:#include <time.h>\n\nsrand(time(NULL));\nint x = rand();\n\nLinia 3 din codul anterior generează seedul de la care se vor genera ulterior numerele aleatorii.\nAceasta, reprezentând o inițializare, este necesară o singură dată (exceptând cazul în care în aplicație\neste necesară în mod explicit reinițializarea acestuia).\n\nAceastă funcție trebuie utilizată, însă, cu precauție, datorită faptului că prezintă\nprobleme de securitate: dacă sunt necesare numere cu adevărat aleatorii, spre exemplu pentru a\nnu fi știute de terți, funcția nu este potrivită deoarece cunoașterea seedului poate duce la cunoașterea\ntuturor numerelor aleatorii generate ulterior în baza acestuia.\n\nNumărul aleator va fi generat uniform în intervalul [0, RAND_MAX], unde RAND_MAX este, de regulă, 32767.\nÎn cazul în care se dorește generarea unor numere în alt interval, se poate scala rezultatul\nobținut cu funcția rand() la intervalul dorit, cu observația că această scalare nu va conserva\nîntocmai proprietatea de uniformitate a distribuției.\n\nPresupunem că dorim găsirea valorii corespunzătoare lui x din intervalul [x_1, x_2] în\nnoul interval [k_1, k_2]. Pentru scalare vom aplica formula:x_{scale} = (k_2 - k_1)\\frac{x - x_1}{x_2 - x_1} + k_1, \\forall x \\in [x_1, x_2].\n\nAlte funcții pentru generarea de numere aleatorii (provenind din alte biblioteci, nu din cea standard)\npermit generarea și a altor tipuri de distribuții (nu doar uniformă), permit specificarea\nintervalului în care să se găsească numărul (pentru a evita pierderea uniformității la scalare)\nsau specifică în mod explicit algoritmul de generare a numerelor.\nPentru scopul educativ al aplicațiilor din acest manual, însă, funcția rand() este suficient de bună.","type":"content","url":"/laborator3#id-1-numere-aleatorii","position":3},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"2) Pointeri"},"type":"lvl2","url":"/laborator3#id-2-pointeri","position":4},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"2) Pointeri"},"content":"În mod obișnuit, o variabilă este înțeleasă ca un nume simbolic care are asociat un tip de date și\no valoare (de exemplu, int x = 2).\nAceastă definiție este valabilă până în momentul compilării, al cărei scop, printre altele,\neste de a traduce expresiile ce folosesc denumiri simbolice în instrucțiuni cod mașină.\nDin momentul compilării, variabilele devin adrese de memorie, iar valorile lor asociate sunt valorile\ncare se găsesc în respectivele adrese.\n\nVariabilele de tip pointeri sunt un tip de date care nu stochează direct o valoare, ci adresa unei locații de memorie.\nDe cele mai multe ori este vorba de o locație de memorie unde se găsește o valoare a altei variabile.\n\nUn pointer are, ca orice alt tip de variabilă, asociate o adresă și o valoare.\nPresupunem că un pointer p este folosit pentru a reține adresa unei variabile x.\n\nValoarea lui p este egală cu adresa variabilei x.\n\nAdresa lui p va fi deci adresa unde este stocată adresa variabilei x. %Adresa lui \\lstinline|p| este adresa de memorie la care se găsește pointerul \\lstinline|p|, deci va fi adresa unde este stocată adresa variabilei \\lstinline|x|. \\\\  %Valoarea \\textit{r-value} a lui \\lstinline|p| este egală cu \\textit{l-value} a variabilei \\lstinline|x| (adresa variabilei~\\lstinline|x|). \\\\\n%Valoarea \\textit{l-value} a lui \\lstinline|p| este adresa de memorie la care se găsește pointerul \\lstinline|p|, deci va fi adresa unde este stocată adresa variabilei \\lstinline|x|. \\\\ ","type":"content","url":"/laborator3#id-2-pointeri","position":5},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"3) Operații cu pointeri"},"type":"lvl2","url":"/laborator3#id-3-opera-ii-cu-pointeri","position":6},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"3) Operații cu pointeri"},"content":"Pointerii sunt tipuri de date derivate.\nPentru a declara un pointer către o variabilă de tip int se  utilizează int *, pentru a declara un\npointer către o variabilă de tip void se utilizează void * ș.a.m.d..\nAșadar un pointer nu este doar o adresă, ci o adresă care are asociată un tip de date.\n\nCu toate că este necesară specificarea tipului de date către care referențiază un pointer,\nspațiul pe care îl ocupă este același indiferent de tipul variabilei a cărei adresă o stochează:\nvaloarea tuturor pointerilor este o adresă.\nMai exact, spațiul ocupat de un pointer este de 4 sau 8 biți (în funcție de arhitectură).\nDe aici decurge un beneficiu al utilizării pointerilor: dacă se dorește transmiterea unei\nvariabile (spre exemplu, într-o funcție), este mai eficientă transmiterea adresei acesteia,\nprintr-un pointer, decât a valorii, prin variabila propriu-zisă, care poate fi mult mai mare decât 4 biți.\n\nDeoarece pointerii fac legătura dintre o valoare și adresa la care este salvată aceasta,\nlucrul cu pointerii presupune două tipuri de operații:\n\ndându-se o variabilă, se dorește aflarea adresei de memorie unde se găsește și\n\ndându-se o adresă, se dorește aflarea valorii salvate acolo.\n\nPrima operație se efectuează cu operatorul referință, &, care calculează adresa elementului către care\nindică un pointer.int x;\nint* p;\nx = 5;\np = &x;\t// p stores the address of x\n\nOperația inversă se realizează cu operatorul de dereferențiere *, care urmărește referința\nunui pointer, cu scopul de a recupera valoarea către care indică.\nPrin urmare, utilizând operatorii * și & putem obține o echivalență de tipul:\n\n*p -> x -> *(&x)\n\nEvident, pentru a putea utiliza operatorul de dereferențiere, pointerul trebuie să conțină o adresă validă.\nDacă un pointer este declarat ca variabilă globală, însă neinițializat, el va fi în mod automat inițializat cu\nNULL, adică o constantă care semnalează că pointerul nu referențiază ceva.\nÎn cazul în care variabila este locală, un pointer va fi inițializat implicit cu o valoare aleatorii\n(ca orice variabilă, de altfel), care poate corespunde unei adrese de memorie neaccesibile programatorului.\nEste inclusă aici situația în care pointerul este declarat în main(), care este de asemenea o funcție.\nPentru a evita eventuale erori (de logică), este indicată inițializarea cu NULL a pointerilor declarați locali.\n\nPointeri au avantajul că oferă programatorului posibilitatea de a lucra direct cu memoria, dar\nnecesită și atenție în plus.\n\nÎn exemplul următor pointerii p1 și p2 referențiază către aceeași zonă de memorie, în care\nse găsește variabila x. Cazul corespunde diagramei din stânga din figura {{< addlink name=“pointeri-2” text=“de mai sus” >}}.\n\nOrice modificare adusă lui x prin intermediul lui p1 va fi vizibilă și pentru p2 și viceversa.\nÎn acest caz, p2 se numește copie superficială.\nDupă execuția liniei 6 din exemplul de mai jos, dacă dorim să aflăm ce valoare se află salvată la\nadresa de memorie stocată în pointerul p1, vom utiliza operatorul de referință, *p1 și vom obține\nvaloarea 6, anume cea a variabilei x1 incrementată. Același rezultat îl vom obține și prin *p2.\n\nÎn capitolul următor vom întâlni un exemplu de situație în care o astfel de copie este utilă.\n\nint x1;\nint* p1, p2;\nx1 = 5;\np1 = &x1;\np2 = p1;\nx1++;\n\nCopie superficiala\n\nAlteori, din contră, este nevoie ca acțiunea a doi pointeri diferiți asupra unei valori să fie realizată\nindependent. Această situație se poate rezolva creând o copie a variabilei, ca în exemplul de mai jos.\nÎn acest caz, ce corespunde diagramei din dreapta din figura {{< addlink name=“pointeri-2” text=“de mai sus” >}}, p2 se numește copie adâncă.\nDupă execuția liniei 7 din exemplul de mai jos, dacă afișăm valoarea stocată la adresa de memorie\npe care o reține pointerul p1, utilizând operatorul *, vom obține valoarea 6, anume cea a\nvariabilei x1 incrementată. În schimb, *p2 va returna valoarea 5, deoarece aceasta se găsește\nla altă locație de memorie față de cea a variabilei x1.\n\nint x1, x2;\nint* p1, p2;\nx1 = 5;\nx2 = x1;\np1 = &x1;\np2 = &x2;\nx1++;\n\nCopie adanca","type":"content","url":"/laborator3#id-3-opera-ii-cu-pointeri","position":7},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"4) Pointeri și tablouri"},"type":"lvl2","url":"/laborator3#id-4-pointeri-i-tablouri","position":8},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"4) Pointeri și tablouri"},"content":"Atunci când se declară o variabilă de tip tablou, numele său este echivalent cu un pointer\ncătre adresa primului element din tablou.\nVariabila în sine nu este un pointer, dar se comportă ca și cum ar fi.\nRegula care face posibilă această echivalență se numește decay to pointer.\n\nExistă doar trei excepții, situații în care variabila se comportă conform tipului ei,\nnu ca un pointer, și anume: utilizarea variabilei împreună cu operatorul sizeof, cu operatorul referință,\n&, și cazul în care variabila este un tablou de\ncaractere inițializat cu valoare constantă (de ex. const char* nume = \"Popescu\";).\n\nÎn exemplul de mai jos se afișează dimensiunea tabloului a, iar rezultatul este 40, anume spațiul\npentru 10 elemente de tip int, a câte 4 biți fiecare.\nDacă sizeof nu ar constitui o excepție de la decay to pointer, rezultatul ar fi dimensiunea\nunui pointer la int și ar fi destul de nefolositor.\n\nint a[10];\nprintf(\"sizeof a: %zu \\n\", sizeof(a));\n\nAflarea dimensiunii unui tablou\n\nÎnsă, odată ce un tablou a fost echivalat cu un pointer (s-a produs decay to pointer), nu se mai\npoate reveni la tablou, variabila trebuie tratată ca pointer.\nAceastă situație se întâmplă, cel mai adesea, când un tablou este transmis\nîntr-o funcție, ca în exemplul următor.\n\nvoid f(int* x){\n\tprintf(\"sizeof x: %zu\", sizeof(x));\n}\n\nint main(){\n\tint v[10];\n\tprintf(\"sizeof v: %zu\", sizeof(v));\n\n\tf(v);\n\treturn 0;\n}\n\nDecay to pointer\n\nFuncția f primește ca parametru un pointer.\nÎn main este apelată cu tabloul v, ceea nu contravine compatibilității între tipurile de date,\navând în vedere că v este echivalent cu un pointer.\nÎnsă atunci când se încearcă aflarea dimensiunii lui x în interiorul funcției,\nrezultatul este 8, anume dimensiunea unui pointer, și nu 40, dimensiunea tabloului.\n\nMai mult, operatorul [], prin care se indexează un vector este implementat în C sub forma\nv[i] == *(v + i).\n\nDatorită faptului că tabloul poate fi folosit ca pointer (mai puțin în excepțiile discutate anterior),\nîn practică apare rar situația în care este nevoie ca o variabilă să fie un pointer la tablou.\nÎnsă acest tip poate apărea în programe ca o consecință a decay to pointer:\ndacă o matrice este transmisă într-o funcție (similar cu felul în care vectorul v este\ntransmis în f în exemplul anterior), variabila va fi echivalată cu un pointer la tablou.","type":"content","url":"/laborator3#id-4-pointeri-i-tablouri","position":9},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"5) Alocarea dinamică"},"type":"lvl2","url":"/laborator3#id-5-alocarea-dinamic","position":10},{"hierarchy":{"lvl1":"Laborator 3 - Valori si adrese","lvl2":"5) Alocarea dinamică"},"content":"În limbajul C alocarea, realocarea și dealocarea dinamică a spațiului se face cu ajutorul următoarelor funcții:void* malloc(size_t size);\nvoid* calloc(size_t num, size_t size);\nvoid* realloc(void* p, size_t new_size);\nvoid* free(void* p);\n\nFuncțiile pentru alocare de spațiu (malloc, calloc, realloc) returnează un pointer către zona\nde memorie care a fost alocată.\nÎn cazul în care nu s-a putut realiza alocarea, pointerul returnat este NULL.\nDin acest motiv, este necesară testarea valorii acestuia pentru a verifica alocarea.\n\nDiferența dintre funcțiile malloc și calloc este că prima (sau malloc) nu inițializează datele,\niar a doua (adica calloc) inițializează variabila pentru care se alocă spațiu cu 0 sau NULL\n(în funcție de tipul acesteia).\n\nPentru a realoca spațiul pentru o variabilă, se folosește funcția realloc.\nAceasta primește ca parametru un pointer către zona de memorie care trebuie realocată și\nnoua dimensiune necesară.\nÎn cazul în care funcția realloc primește ca parametru pointer la NULL, aceasta se comportă la fel ca\nfuncția malloc.\nDacă realocarea nu s-a putut realiza (spre exemplu, din lipsă de spațiu), realloc va returna un\npointer NULL.\nDe aceea, este indicat să se evite suprascrierea directă a unui pointer ca urmare a realocării,\ndeoarece se poate pierde adresa datelor.\nO copie (superficială) a acestora poate preîntâmpina această situație.\n\nÎn momentul în care variabila către care referențiază pointerul nu mai este necesară, se recomandă\neliberarea spațiului și setarea pointerului la valoarea NULL.\nSe evită astfel situația în care zona de memorie a fost eliberată, dar pointerul indică în continuare\ncătre ea dangling pointer).\n\nEchivalența dintre pointeri și tablouri face posibil ca pointerul returnat de\nfuncția malloc să fie interpretat ca tablou și folosit ca atare.\nÎn exemplul următor este alocat spațiu pentru trei întregi și returnat pointerul p\ncătre blocul respectiv de memorie.\nPointerul poate fi folosit ca un tablou de trei elemente, cu indexarea specifică tablourilor, [].\n\nint dim = 3;\nint* p = (int*) malloc(dim * sizeof(int));\np[1] = 1234;\nprintf(\"p[1] = %d\", p[1]);\n\nInițializarea unui tablou ca pointer","type":"content","url":"/laborator3#id-5-alocarea-dinamic","position":11},{"hierarchy":{"lvl1":"Laborator 4 - Liste"},"type":"lvl1","url":"/laborator4","position":0},{"hierarchy":{"lvl1":"Laborator 4 - Liste"},"content":"","type":"content","url":"/laborator4","position":1},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"1) Liste simplu înlănțuite"},"type":"lvl2","url":"/laborator4#id-1-liste-simplu-nl-n-uite","position":2},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"1) Liste simplu înlănțuite"},"content":"O listă simplu înlănțuită este o structură liniară de date, în care fiecare element (denumit și nod)\nconține, pe lângă informația utilă, adresa elementului următor. Excepție face ultimul element al\nlistei, a cărui adresă următoare este NULL.\nFigura {{< addlink name=“figura1” text=“de mai jos” >}} prezintă structura unei liste.\n\nUn element al listei poate fi declarat ca o structură, ca în exemplul următor:\n\nstruct Elem {\n    int val;            // info about the node\n    struct Elem* next;  // adress of the next node\n};\n\ntypedef struct Elem Node;\n\nDeclararea unui element de listă\n\nLista poate fi parcursă doar element cu element, spre exemplu de la stânga la dreapta.\nNu există posibilitatea de a reveni la un element anterior, de aceea adresa de început\na listei trebuie cunoscută mereu, pentru a putea relua parcurgerea de câte ori este nevoie.\n\nToate operațiile care presupun schimbarea structurii unei liste (inserarea sau ștergerea de elemente)\nnecesită refacerea legăturilor între elementele acesteia.\nDatorită tipului de organizare secvențial, poziția unui element în listă (început, final sau\nun element oarecare) influențează modul în care acesta trebuie tratat în diferite operații.\n\nPrezentăm în continuare operația de adăugare a unui element în listă; cea de ștergere este\nlăsată ca exercițiu cititorului.","type":"content","url":"/laborator4#id-1-liste-simplu-nl-n-uite","position":3},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"2) Adăugarea unui element la începutul listei"},"type":"lvl2","url":"/laborator4#id-2-ad-ugarea-unui-element-la-nceputul-listei","position":4},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"2) Adăugarea unui element la începutul listei"},"content":"Pentru a crea o listă și a adăuga un element se urmează pași:\n\ndeclararea unui pointer, denumit în continuare head și inițializarea acestuia cu NULL.\nAcesta va reprezenta începutul listei;\n\ncrearea unui element de listă;\n\nactualizarea pointerului head cu adresa noului element creat.\n\nFigura {{< addlink name=“figura2” text=“de mai jos” >}} prezintă schematic această operație de adăugare.\nObservați că pointerul next al noul nod creat are valoarea NULL.\n\nÎn cazul în care se dorește adăugarea unui element la începutul unei liste care conține deja cel puțin un nod, pașii de urmat sunt:\n\nCrearea unui element de listă.\n\nLegarea noului nod la primul element existent în listă prin setarea pointerul next al noului nod\nla adresa primul nod din listă.\n\nActualizarea începutului listei prin setarea pointerului head la adresa noului element introdus.\n\nSchema acestei operații este prezentată în figura {{< addlink name=“figura3” text=“de mai jos” >}}.\nObservați că adăugarea unui nod nou presupune ștergerea unei legături deja existente în\nlistă și adăugarea a două legături noi.\nAceste operații sunt necesare indiferent de poziția în listă unde se dorește introducerea unui element.\nȘtergerea legăturii vechi nu se realizează explicit, ea se realizează prin adăugarea celor două legături\nnoi, desenate cu albastru în figură.\nOrdinea în care se creează aceste două legături este importantă: dacă am crea întâi legătura din\nstânga (care presupune setarea adresei începutului listei la noul element) s-ar pierde adresa\nprimului element și nu ar mai putea fi stabilită legătura din dreapta.\nPrin urmare, întotdeauna, prima legătură care se realizează este cea din dreapta.","type":"content","url":"/laborator4#id-2-ad-ugarea-unui-element-la-nceputul-listei","position":5},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"3) Adăugarea unui element oarecare în listă"},"type":"lvl2","url":"/laborator4#id-3-ad-ugarea-unui-element-oarecare-n-list","position":6},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"3) Adăugarea unui element oarecare în listă"},"content":"Cazul în care un nod nou trebuie adăugat pe o poziție oarecare este similar adăugării la\nînceputul listei, însă necesită o operație suplimentară: lista trebuie parcursă până se ajunge la\nelementul dinaintea poziției în care se dorește adăugarea nodului. Pointerul next al acestui element\nva fi actualizat cu adresa nodului nou, însă nu înainte de a lega noul nod la\nelementul următor din listă (legătura din dreapta).\n\nParcurgerea listei presupune avansarea element cu element utilizând pointerii next, până se ajunge\nla NULL, ca în exemplul de mai jos.\n\nwhile (head != NULL) {\n\thead = head->next;\n}\n\nParcurgerea listei\n\nVariabila head este un pointer, care la început reprezintă începutul listei.\nLa fiecare pas al acestei structuri repetitive, însă, adresa de memorie către care\nindică acest pointer se va modifica, astfel că se va pierde adresa de început.\nPentru a evita această situație, de fiecare dată când este necesară parcurgerea unei liste,\ndar și reținerea primei adrese, se va face o copie superficială a adresei primului element.\nFigura {{< addlink name=“figura4” text=“de mai jos” >}} prezintă schema acestei operații de adăugare.","type":"content","url":"/laborator4#id-3-ad-ugarea-unui-element-oarecare-n-list","position":7},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"4) Adăugarea unui element la sfârșitul listei {#adaugarea-unui-element-la-sfarsitul-listei}"},"type":"lvl2","url":"/laborator4#id-4-ad-ugarea-unui-element-la-sf-r-itul-listei-adaugarea-unui-element-la-sfarsitul-listei","position":8},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"4) Adăugarea unui element la sfârșitul listei {#adaugarea-unui-element-la-sfarsitul-listei}"},"content":"Figura {{< addlink name=“figura5” text=“de mai jos” >}} prezintă cazul în care un element este introdus la finalul listei.\nOperația presupune parcurgerea listei până la ultimul element și actualizarea\npointerului next al acestuia cu adresa noului nod.","type":"content","url":"/laborator4#id-4-ad-ugarea-unui-element-la-sf-r-itul-listei-adaugarea-unui-element-la-sfarsitul-listei","position":9},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"5) Liste dublu înlănțuite"},"type":"lvl2","url":"/laborator4#id-5-liste-dublu-nl-n-uite","position":10},{"hierarchy":{"lvl1":"Laborator 4 - Liste","lvl2":"5) Liste dublu înlănțuite"},"content":"Faptul că o listă simplu înlănțuită poate fi parcursă într-o singură direcție și nevoia\nde a reține o copie a adresei de început a unei liste, pentru a evita pierderea acesteia\natunci când lista este parcursă reprezintă două inconveniente ale listelor simplu înlănțuite.\nAcestea pot fi rezolvate prin adăugarea în structura unui element de listă a unui pointer\ncătre elementul anterior.\nLista care rezultă din această operație se numește listă dublu înlănțuită.\n\nstruct Elem {\n\tint val;            // informatia utila\n\tstruct Elem* prev;  // adresa nodului anterior\n\tstruct Elem* next;  // adresa nodului urmator\n};\n\ntypedef struct Elem Node;\n\nElement al unei liste dublu înlănțuite\n\nPointerul prev al primului element din listă are valoarea NULL pentru a semnala începutul listei.\n\nAvantajul de a putea parcurge liste în ambele direcții vine cu inconvenientul operațiilor\nsuplimentare atunci când se dorește adăugarea, modificarea sau ștergerea\nunui element dintr-o listă dublu înlănțuită: trebuie actualizate atât legăturile către\nelementul următor (prin pointerul next), cât și cele către elementul\nanterior (prin pointerul prev).","type":"content","url":"/laborator4#id-5-liste-dublu-nl-n-uite","position":11},{"hierarchy":{"lvl1":"Proiectarea Algoritmilor"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Proiectarea Algoritmilor"},"content":"Proiectarea Algoritmilor\n\nExplorarea tehnicilor fundamentale și avansate pentru proiectarea și analiza algoritmilor, alături de implementarea structurilor de date esențiale.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Proiectarea Algoritmilor","lvl2":"Obiectivele cursului"},"type":"lvl2","url":"/#obiectivele-cursului","position":2},{"hierarchy":{"lvl1":"Proiectarea Algoritmilor","lvl2":"Obiectivele cursului"},"content":"Înțelegerea și analiza complexității algoritmilor\n\nStăpânirea tehnicilor de proiectare a algoritmilor: greedy, backtracking, programare dinamică, divide et impera\n\nImplementarea eficientă a structurilor de date (liste, stive, cozi, arbori, grafuri)","type":"content","url":"/#obiectivele-cursului","position":3},{"hierarchy":{"lvl1":"Proiectarea Algoritmilor","lvl2":"Anunțuri importante"},"type":"lvl2","url":"/#anun-uri-importante","position":4},{"hierarchy":{"lvl1":"Proiectarea Algoritmilor","lvl2":"Anunțuri importante"},"content":"Test grilă: Săptămâna 9\n\nPredare Proiect 1: Săptămânile 6 și 14\n\nExamen final: Minim 20p necesare pentru promovare\n\nDeadline Proiect 2: Săptămâna 14\n\nTip\n\nSucces la curs! Fie ca algoritmii tăi să fie întotdeauna optimi.","type":"content","url":"/#anun-uri-importante","position":5},{"hierarchy":{"lvl1":"Style Guide"},"type":"lvl1","url":"/styleguide","position":0},{"hierarchy":{"lvl1":"Style Guide"},"content":"","type":"content","url":"/styleguide","position":1},{"hierarchy":{"lvl1":"Style Guide","lvl2":"Headere si sectiuni"},"type":"lvl2","url":"/styleguide#headere-si-sectiuni","position":2},{"hierarchy":{"lvl1":"Style Guide","lvl2":"Headere si sectiuni"},"content":"Pentru a evita probleme la imbricarea sectiunilor, se folosesc h2 pentru titlurile principale din pagina. In acelasi timp, titlul paginii se va defini in frontmatter, nu prin markdown, pentru a avea control asupra toc-ului.\n\nNumele sectiunilor trebuie sa fie normal scris, fara adaugari hard-coded precum numere de forma 1) sau alte stiluri ce pot fura din atentie---\ntitle: \"Titlu\"\n---\n\n## Prima sectiune\n\nSubsectiunile folosesc header daca sunt destul de importante incat sa se afle in lista continuturilor, caz in care numarul acestora este cu 1 mai mare decat al header-ului parinte. In cazul in care subsectiunea nu este destul de importanta, se va folosi bold pe prima idee a primului paragraf.## Prima sectiune\n### Prima subsectiune\n\n## A doua sectiune\n**Asa arata** o alta idee ce merita propriul paragraf.","type":"content","url":"/styleguide#headere-si-sectiuni","position":3},{"hierarchy":{"lvl1":"Style Guide","lvl2":"Definitii si observatii"},"type":"lvl2","url":"/styleguide#definitii-si-observatii","position":4},{"hierarchy":{"lvl1":"Style Guide","lvl2":"Definitii si observatii"},"content":"Pentru definitii se vor folosi admonitii de tip note avand ca titlu notiunea definita. Similar, pentru observatii, se vor folosi admonitii de tip tip avand optional un titlu reprezentativ","type":"content","url":"/styleguide#definitii-si-observatii","position":5},{"hierarchy":{"lvl1":"Style Guide","lvl2":"Notiuni si emphasis"},"type":"lvl2","url":"/styleguide#notiuni-si-emphasis","position":6},{"hierarchy":{"lvl1":"Style Guide","lvl2":"Notiuni si emphasis"},"content":"Cand se doreste scrierea clara a unei denumiri se va folosi sintaxa pentru cod inline, iar pentru emphasis se va folosi sintaxa pentru text boldAceasta este o notiune, denumita si `notiune`. \n\nVreau sa adaug emphasis pe **acest cuvant**.","type":"content","url":"/styleguide#notiuni-si-emphasis","position":7}]}